package threadmgr

import (
	"log"
	"sync"

	//	"github.com/sasha-s/go-deadlock"

	np "ulambda/ninep"
)

type Thread struct {
	sync.Locker
	newOpCond *sync.Cond // signalled when there are new ops available.
	cond      *sync.Cond // Signalled when the thread can start to make progress.
	done      bool
	ops       []*Op // List of ops to process.
	wakeups   []*sync.Cond
	pfn       ProcessFn
}

func makeThread(pfn ProcessFn) *Thread {
	t := &Thread{}
	t.Locker = &sync.Mutex{}
	t.newOpCond = sync.NewCond(t.Locker)
	t.cond = sync.NewCond(t.Locker)
	t.ops = []*Op{}
	t.wakeups = []*sync.Cond{}
	t.pfn = pfn
	return t
}

// Process a new op.
func (t *Thread) Process(fc *np.Fcall, replies chan *np.Fcall) {
	t.Lock()
	defer t.Unlock()
	//	log.Printf("%v.%v threadmgr request process %v", fc.Session, fc.Seqno, fc)
	t.ops = append(t.ops, makeOp(fc, replies))
	// Signal that there are ops to be processed.
	t.newOpCond.Signal()
}

// Assumes that the caller holds the *t.Mutex. Called when an operation is
// going to sleep (or has terminated). If the op has terminated, c will be nil.
// This function assumes that there is only ever one goroutine waiting on each
// cond.
func (t *Thread) Sleep(c *sync.Cond) {
	//	log.Printf("threadmgr(%p) Sleep %p", t, c)
	// Reacquire the *t.Mutex
	t.Lock()
	/// Notify the thread that this goroutine is going to sleep.
	t.cond.Signal()
	// Allow the thread to make progress, as this goroutine is about to sleep.
	t.Unlock()
	c.Wait()
	//	log.Printf("threadmgr(%p) Sleep %p done", t, c)
}

// Called when an operation is going to be woken up. The caller may be a
// goroutine/operation belonging to this thread/session (in which case
// holdsLock is true) or the goroutine/operation may belong to another
// thread/session (in which case holdsLock is false).
func (t *Thread) Wake(c *sync.Cond) {
	t.Lock()
	defer t.Unlock()
	//	log.Printf("threadmgr(%p) Wake %p", t, c)
	// Append to the list of goroutines to be woken up.
	t.wakeups = append(t.wakeups, c)
	// Notify thread that there are more wakeups to be processed.
	t.newOpCond.Signal()
}

// Processes operations on a single channel.
func (t *Thread) run() {
	t.Lock()
	for {
		for len(t.ops) == 0 && len(t.wakeups) == 0 {
			if t.done {
				log.Printf("Thread done")
				return
			}
			t.newOpCond.Wait()
		}

		// If there is a new op to process, process it.
		if len(t.ops) > 0 {
			// Get the next op.
			op := t.ops[0]
			t.ops = t.ops[1:]
			//			log.Printf("%v.%v threadmgr(%p) Start process %v", op.fc.Session, op.fc.Seqno, t, op.fc)
			// Process the op.
			go func() {
				t.pfn(op.fc, op.replies)
				// Lock to make sure the signal isn't missed.
				t.Lock()
				// Notify the thread that the op has completed.
				t.cond.Signal()
				t.Unlock()
				//				log.Printf("%v.%v threadmgr(%p) done processing goroutine %v", op.fc.Session, op.fc.Seqno, t, op.fc)
			}()
			//			log.Printf("%v.%v threadmgr(%p) wait for sleep/finish %v", op.fc.Session, op.fc.Seqno, t, op.fc)
			// Wait for the op to sleep or complete.
			t.cond.Wait()
			//			log.Printf("%v.%v threadmgr(%p) done wait for sleep/finish %v", op.fc.Session, op.fc.Seqno, t, op.fc)
		}
		//		log.Printf("threadmgr(%p) process wakeups", t)
		// Process any pending wakeups. These may have been generated by a new op,
		// or by another thread in the system.
		t.processWakeups()
		//		log.Printf("threadmgr(%p) DONE process wakeups", t)
	}
}

// Processes wakeups on a single channel. Assumes t.Mutex is held.
func (t *Thread) processWakeups() {
	tmp := []*sync.Cond{}
	for _, c := range t.wakeups {
		tmp = append(tmp, c)
	}
	// Empty the wakeups list.
	t.wakeups = t.wakeups[:0]
	for _, c := range tmp {
		//		log.Printf("threadmgr(%p) Signal cond %p for wakeup", t, c)
		// Wake up the sleeping goroutine.
		c.Signal()
		// Wait for the operation to sleep or terminate.
		t.cond.Wait()
		//		log.Printf("threadmgr(%p) Cond %p for wakeup went back to sleep or terminated", t, c)
	}
}

func (t *Thread) start() {
	go t.run()
}

func (t *Thread) stop() {
	t.Lock()
	defer t.Unlock()
	log.Fatalf("STOPPING THREAD ==========================")
	t.done = true
	t.cond.Signal()
}
