package group

import (
	"ulambda/proc"
	"ulambda/procclnt"
)

const (
	NMEMBER = 1
)

type Member struct {
	*procclnt.ProcClnt
	pid   string
	bin   string
	group string
}

func (m *member) spawn() {
	p := proc.MakeProc(m.bin, []string{m.group})
	// p.AppendEnv("SIGMACRASH", strconv.Itoa(c.crash))
	m.Spawn(p)
	m.WaitStart(p.Pid)
	m.pid = p.Pid
}

func (m *member) run(i int, start chan bool, done chan procret) {
	//log.Printf("spawn %p member %v\n", c, c.bin)
	m.spawn()
	//log.Printf("member %p forked %v\n", c, c.pid)
	start <- true
	status, err := m.WaitExit(c.pid)
	//log.Printf("member %v exited %v err %v\n", c.pid, status, err)
	done <- procret{i, err, status}
}

func makeMember(pclnt *procclnt.ProcClnt, bin, group string) *member {
	m := &Member{}
	m.ProcClnt = pclnt
	m.bin = bin
	m.group = group
	return m
}

type procret struct {
	member int
	err    error
	status string
}

type Gmgr struct {
	stop    bool
	members []*Member
	ch      chan bool
}

func MakeMgr(pclnt *procclnt.ProcClnt, name, bin string) *Gmgr {
	gm := &Gmgr{}
	gm.startMembers(gm.ProcClnt, name, bin)
	return gm
}

func (gm *Gmgr) startMembers() {
	gm.members = make([]*Member, NMEMBER)
	for i := 0; i < NMEMBER; i++ {
		gm.members[i] = makeMember(gm.ProcClnt, name, bin)
	}
	done := make(chan procret)
	for i, m := range cm.members {
		start := make(chan bool)
		go m.run(i, start, done)
		<-start
	}
	go gm.manager(done)
}

func (gm *Gmgr) manager(done chan procret) {
	n := NCOORD
	for n > 0 {
		st := <-done
		if gm.stop {
			n--
		} else if st.err == nil && st.status == "OK" { // done?
			gm.stop = true
			n--
		} else { // restart coord i
			start := make(chan bool)
			go gm.members[st.coord].run(st.coord, start, done)
			<-start
		}
	}
	gm.ch <- true
}

func (gm *Gmgr) Wait() {
	<-gm.ch
}

func (gm *Gmgr) Stop() error {
	// coordinators may not run in order of members, and blocked
	// waiting for Wlease, while the primary keeps running,
	// because it is later in the list.
	gm.stop = true
	var err error
	for _, c := range gm.members {
		go func(c *coord) {
			// log.Printf("evict %v\n", c.pid)
			r := c.Evict(c.pid)
			if r != nil {
				err = r
			}
		}(c)
	}
	// log.Printf("wait for coordinators\n")
	<-gm.ch
	log.Printf("done coordinators\n")
	return err
}
